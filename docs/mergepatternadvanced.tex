\section{ادغام پیشرفته‌تر با \lr{Galloping}}
\begin{frame}{تکنیک \lr{Galloping}}
\begin{itemize}\itemr
\item[-]
چنین سناریویی را تصور کنید: ما این آرایه‌ را داریم:

\begin{lfl}
\m{A = [\, \underbrace{\m{1, 2, 3, 6, 10}}_{\m{X}}, \, \underbrace{\m{4, 5, 7, 9, 12, 14, 17}}_{\m{Y}} \,] }
\end{lfl}

\item[-]
در تکنیک \lr{Galloping}، ما با استفاده از \lr{binary search} مکان اولین عضو 
\m{Y}
را در 
\m{X}
پیدا می‌کنیم که می‌بینیم در جایگاه ۴ باید آن را بگذاریم، این یعنی عناصر قرمز در جایگاه واقعی و درست خود هستند:
\begin{lfl}
\m{A = [\, \underbrace{\m{\textcolor{red}{\m{1, 2, 3}}, 6, 10}}_{\m{X}}, \underbrace{\m{\textcolor{blue}{\m{4}}, 5, 7, 9, 12, 14, 17}}_{\m{Y}}\,]
}\end{lfl}

\item[-]
همین کار را برای آخرین عنصر 
\m{X}
نسبت به 
\m{Y}
انجام می‌دهیم که مکان آن در جایگاه پنجم دومین \lr{Run} است و یعنی تمامی عناصر قرمز در جایگاه درست و واقعی خود قرار دارند:
\begin{lfl}
\m{A = [\, \underbrace{\m{1, 2, 3, 6, \textcolor{blue}{\m{10}}}}_{\m{X}}, \underbrace{\m{4, 5, 7, 9, \textcolor{red}{\m{12, 14, 17}}}}_{\m{Y}}\,]}
\end{lfl}
\end{itemize}
\end{frame}

\begin{frame}{تکنیک \lr{Galloping} (ادامه)}
\begin{itemize}\itemr
\item[-]
پس ما چنین آرایه‌ای داریم:
\begin{lfl}
\m{A = [\textcolor{red}{\m{1, 2, 3}}, \, \underbrace{\m{6, 10}}_{\m{X}}, \, \underbrace{\m{4, 5, 7, 9}}_{\m{Y}}, \textcolor{red}{\m{12, 14, 17}}]}
\end{lfl}
و صرفا باید الگوریتم ادغامی که بالاتر بحث شد را روی این 
\m{X}
و 
\m{Y}
کوچک‌تر انجام بدهیم که هم سریع‌تر است و هم فضای کمتری استفاده خواهد کرد.
\end{itemize}
\end{frame}

\begin{frame}{تکنیک \lr{Galloping} (ادامه)}
\begin{itemize}\itemr
\item[-]
نکته‌ای که در تکنیک \lr{Galloping} وجود دارد اینست که این روش فقط بعضی وقت‌ها فقط به نفع ماست. به این مثال دقت کنید:
\begin{lfl}
\m{A = [\underbrace{\m{1, 3, 5, 7, 9}}_{\m{X}}, \, \underbrace{\m{2, 4, 6, 8, 10}}_{\m{Y}}\,]}
\end{lfl}

\item[-]
ابتدا مکان ۲ را در 
\m{X}
پیدا می‌کنیم که در جایگاه دوم باید قرار بگیرد و سپس مکان ۹ را پیدا می‌کنیم که در جایگاه پنجم باید قرار بگیرد.

\item[-]
که به چنین آرایه‌ای می‌رسیم:
\begin{lfl}
\m{A = [\textcolor{red}{1}, \underbrace{\m{3, 5, 7, 9}}_{\m{X}}, \, \underbrace{\m{2, 4, 6, 8}}_{\m{Y}}, \textcolor{red}{10}]}
\end{lfl}

که مشخصا هیچ بهبودی را برای ما نداشت هیچ، بلکه چندین مقایسه اضافه‌ هم با \lr{Binary Search} انجام داده‌ایم.
\end{itemize}
\end{frame}

\begin{frame}{تکنیک \lr{Galloping} (ادامه)}
\begin{itemize}\itemr
\item[-]
طبق تست‌هایی که تیم پیترز انجام داده است، تعداد عنصری که باید سر جای خودشان باشند، در ابتدای الگوریتم، باید حداقل ۷ تا باشد که این عدد نام \lr{\texttt{min\_gallop}} دارد. این یعنی اگر جایگاه اولین عنصر 
\m{Y}
را در 
\m{X}
پیدا کنیم و ۷ عنصر در جایگاه خودشان باشند، این تکنیک موثر خواهد بود (همین برای پیدا کردن آخرین عنصر \m{X} در \m{Y} هم صدق می‌کند.)

\item[-]
در ادغام کردن اگر حالت اول (مکان اولین عنصر \m{Y} در \m{X}) \textbf{\underline{یا}} حالت دوم (مکان آخرین عنصر \m{X} در \m{Y}) بزرگ‌تر مساوی \lr{\texttt{min\_gallop}} بود، از این تکنیک استفاده می‌شود.

\item[-]
بعد از هر بار موفق بودن \lr{galloping} عدد \lr{\texttt{min\_gallop}} به عنوان یک تشویق برای الگوریتم، یکی کم می‌شود تا در ادامه هم بتوان از \lr{galloping} استفاده کرد.
\end{itemize}
\end{frame}

\begin{frame}{تکنیک \lr{Galloping} (ادامه)}
\begin{itemize}\itemr
\item[-]
حالت عکس هم چنین است که مکان پیدا شده کمتر از 
\lr{\texttt{min\_gallop}}
باشد که یعنی این تکنیک موثر نبوده و از حالت مقایسه‌ی ادغامی ساده، یعنی عنصر به عنصر استفاده می‌شود و عدد
\lr{\texttt{min\_gallop}}
به عنوان جریمه یکی زیاد می‌شود.

\item[-]
روش \lr{galloping} در داده‌های واقعی که \lr{partially sorted} هستند بسیار کارآمد است و تعداد مقایسه‌ها را خیلی کمتر می‌کند.

\item[-]
اما در داده‌های رندوم این روش موثر نیست و از مقایسه‌ی عنصر به عنصر استفاده می‌شود که 
\begin{enumerate}\itemr
\item
کد ساده‌ای دارد و
\item
\lr{Locality of Reference}
 خوبی هم دارد.
\end{enumerate}
\end{itemize}
\end{frame}

\begin{frame}{کدها}
\begin{itemize}\itemr
\item[-]
\lr{gallop}
کردن از چپ توسط تابع
\lr{\texttt{gallop\_left()}}\fn{1}{\url{https://github.com/python/cpython/blob/3.10/Objects/listobject.c\#L1371}}
و 
\lr{gallop}
کردن از سمت راست توسط تابع
\lr{\texttt{gallop\_right()}}\fn{2}{\url{https://github.com/python/cpython/blob/3.10/Objects/listobject.c\#L1459}}
انجام می‌شود.

\item[-]
این دو تابع انعکاس آئینه‌ای همدیگر هستند.
\end{itemize}
\end{frame}