\section{چرا تیم‌سورت؟}
\begin{frame}{چرا تیم‌سورت}
\begin{itemize}\itemr
\item[-]
پیچیدگی زمانی الگوریتم تیم‌سورت با الگوریتم‌های 
\lr{Merge sort}،
\lr{Quick sort} و
\lr{Heap sort}
برابری می‌کند و برابر 
\m{O(nlgn)}
است.

\item[-]
اما این تحلیل کلی یک سری جزئیات راجع به پیچیدگی زمانی الگوریتم را پنهان می‌کند که آن پیچیدگی یک 
\lr{constant factor}
اثرگذار در میزان پیچیدگی الگوریتم است. (\m{C_f.nlgn})

\item[-]
برای مثال در الگوریتم \lr{Quick sort} انتخاب مقدار 
\lr{left}،
\lr{right} و
\lr{pivot}
تاثیرگذار است و در \lr{n}های کوچک سرعت را پایین می‌آورد.

\item[-]
الگوریتم 
\lr{Merge sort}
هم ما فضایی به اندازه‌ی \m{n + m} برای ادغام کردن آرایه‌ها آن هم به صورت بازگشتی و تعداد زیاد نیاز دارد.

\item[-]
بخاطر جابجایی‌هایی در الگوریتم \lr{Heap sort} انجام می‌شود، 
\lr{Locality of Reference}
در آن نقض شده و پیشبینی‌های پردازنده‌ برای کش کردن داده‌ها را تضعیف می‌کند.
\end{itemize}
\end{frame}

\begin{frame}{چرا تیم‌سورت}
\begin{center}
{\large \textbf{پس اگر بتوانیم این \lr{constant factor} را کاهش دهیم می‌توانیم سرعت بیشتری از \m{O(nlgn)} بگیریم.}}
\end{center}
\end{frame}

\begin{frame}{مرتب سازی درجی دودویی}
\begin{itemize}\itemr
\item[-]
پیچیدگی زمانی \lr{insertion sort} برابر با 
\m{O(n^2)}
است و 
\lr{constant factor}
آن بسیار بسیار پایین است چون اولا \lr{inplace} عمل می‌کند و ثانیا فقط بین عناصر آرایه پیمایش انجام می‌دهد.

\item[-]
در تحلیل‌های انجام شده روی الگوریتم‌ها، این الگوریتم روی تعداد ورودی ۶۴ و پایین‌تر از الگوریتم‌های دیگر مرتب سازی سریع‌تر عمل می‌‌کند.

\item[-]
الگوریتم 
\lr{binary insertion sort}
بجای جستجوی خطی در آرایه (\m{O(n)}) در آن جستجوی دودویی انجام داده و در زمان لوگاریتمی (\m{O(lgn)}) مکان صحیح آیتم را پیدا می‌‌کند (علت استفاده از این الگوریتم در ادامه روشن خواهد شد.)
\end{itemize}
\end{frame}

\begin{frame}{ایده}
\begin{center}
{\large اگر آرایه را به تکه‌های کوچک تقسیم کنیم‌ (برای مثال ۳۲ تا ۶۴ تایی) و سپس آنها را جدا جدا با مرتب‌ سازی درجی مرتب کنیم و سپس همه را ادغام کنیم، می‌توانیم سرعت مرتب سازی را افزایش دهیم.}
\end{center}

\begin{enumerate}\itemr
\item
چون از مرتب سازی درجی که برای تعداد کم سریع است استفاده کردیم (\m{c_i(32 \ to\ 64)^2})،
\item
ادغام دو آرایه مرتب شده در زمان 
\m{O(n)}
انجام می‌شود و

\item 
با این کار ما توانستیم ۵ سطح از درختی در \lr{Merge sort} تولید می‌شود را کم کنیم (\m{c_t.n[lgn - 5]})
\end{enumerate}

\begin{center}
{\large در نهایت چون مقدار پیچیدگی مرتب سازی درجی کوچک است، پیچیدگی  تیم‌سورت چنین می‌شود: \m{c_t.n[lgn - 5]}}
\end{center}
\end{frame}

\begin{frame}{حقیقت}
\begin{center}
{\large در دنیای واقعی و داده‌های واقعی معمولا آرایه‌ها اصطلاحا 
\lr{partially sorted}
هستند.}
\end{center}
\begin{itemize}\itemr
\item[-]
این به این معناست که تکه‌هایی از آرایه از قبل مرتب هستند؛ برای مثال در این آرایه:
\m{[5, 4, 1, 2, 3]}
قسمت 
\m{[1, 2, 3]}
از قبل مرتب است.
\item[-]
یا حداقل به صورت نزولی یا مرتب پشت سر هم حضور دارند؛ برای مثال در این آرایه:
\m{[6, 4, 1, 2, 3, 5, 7]}
قسمت
\m{[1, 2, 3, 5, 7]}
خودش به صورت صعودی مرتب است.
\end{itemize}

\begin{center}
{\large الگوریتم تیم‌سورت این تکه‌های صعودی و یا اکیدا نزولی را در آرایه پیدا می‌کند و آنها را \lr{Run} می‌نامد و از مرتب بودن اولیه آرایه برای افزارش سرعت استفاده می‌کند.}
\end{center}
\end{frame}

\begin{frame}{نتیجه}
\begin{itemize}\itemr
\item[-]
اگر از حقیقت قبلی استفاده کنیم و آرایه را به قسمت‌هایی صعودی و یا اکیدا نزولی تقسیم کنیم می‌توانیم درخت \lr{Merge sort} حتی بیشتر از قبل هم کوتاه کنیم.

\item[-]
و پیچیدگی را به 
\m{c_t.n[lgn - x]}
تبدیل کنیم.
\end{itemize}
\end{frame}