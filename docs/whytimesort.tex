\section{چرا تیم‌سورت؟}
\begin{frame}{چرا تیم‌سورت؟}
\begin{itemize}\itemr
\item[-]
پیچیدگی زمانی الگوریتم تیم‌سورت با الگوریتم‌های 
\lr{Merge sort}،
\lr{Quick sort} و
\lr{Heap sort}
برابری می‌کند و برابر 
\m{O(nlgn)}
است.

\item[-]
اما این تحلیل کلی یک سری جزئیات راجع به پیچیدگی زمانی الگوریتم را پنهان می‌کند که آن پیچیدگی یک 
\lr{constant factor}
اثرگذار در میزان پیچیدگی الگوریتم است. (\m{c_f.nlgn})

\item[-]
برای مثال در الگوریتم \lr{Quick sort} انتخاب مقدار 
\lr{left}،
\lr{right} و
\lr{pivot}
تاثیرگذار است و در \m{n}های کوچک سرعت را پایین می‌آورد.

\item[-]
در الگوریتم 
\lr{Merge sort}
هم ما فضایی به اندازه‌ی \m{n + m} برای ادغام کردن آرایه‌ها آن هم به صورت بازگشتی و تعداد زیاد نیاز دارد. همچنین این الگوریتم یک الگوریتم بازگشتی‌ست و درخت بازگشتی و یک \lr{system stack} برای اجرا نیاز دارد.

\item[-]
بخاطر جابجایی‌هایی در الگوریتم \lr{Heap sort} انجام می‌شود، 
\lr{Locality of Reference}
در آن نقض شده و پیشبینی‌های پردازنده‌ برای کش کردن داده‌ها را تضعیف می‌کند.
\end{itemize}
\end{frame}

\begin{frame}{چرا تیم‌سورت؟}
\begin{center}
{\Large \textbf{پس اگر بتوانیم این \lr{constant factor} را کاهش دهیم}}

{\Large \textbf{می‌توانیم سرعت بیشتری از \m{O(nlgn)} بگیریم.}}
\end{center}
\end{frame}
