\section{چرا تیم‌سورت؟}
\begin{frame}{چرا تیم‌سورت؟}
\begin{itemize}\itemr
\item[-]
پیچیدگی زمانی الگوریتم تیم‌سورت با الگوریتم‌های 
\lr{Merge sort}،
\lr{Quick sort} و
\lr{Heap sort}
برابری می‌کند و برابر 
\m{O(nlgn)}
است.

\item[-]
اما این تحلیل کلی یک سری جزئیات راجع به پیچیدگی زمانی الگوریتم را پنهان می‌کند که آن پیچیدگی یک 
\lr{constant factor}
اثرگذار در میزان پیچیدگی الگوریتم است. (\m{c_f.nlgn})

\item[-]
برای مثال در الگوریتم \lr{Quick sort} انتخاب مقدار 
\lr{left}،
\lr{right} و
\lr{pivot}
تاثیرگذار است و در \m{n}های کوچک سرعت را پایین می‌آورد.

\item[-]
در الگوریتم 
\lr{Merge sort}
هم ما فضایی به اندازه‌ی \m{n + m} برای ادغام کردن آرایه‌ها آن هم به صورت بازگشتی و تعداد زیاد نیاز دارد. همچنین این الگوریتم یک الگوریتم بازگشتی‌ست و درخت بازگشتی و یک \lr{system stack} برای اجرا نیاز دارد.

\item[-]
بخاطر جابجایی‌هایی در الگوریتم \lr{Heap sort} انجام می‌شود، 
\lr{Locality of Reference}
در آن نقض شده و پیشبینی‌های پردازنده‌ برای کش کردن داده‌ها را تضعیف می‌کند.
\end{itemize}
\end{frame}

\begin{frame}{چرا تیم‌سورت؟}
\begin{center}
{\Large \textbf{پس اگر بتوانیم این \lr{constant factor} را کاهش دهیم}}

{\Large \textbf{می‌توانیم سرعت بیشتری از \m{O(nlgn)} بگیریم.}}
\end{center}
\end{frame}

\begin{frame}{مرتب سازی درجی دودویی}
\begin{itemize}\itemr
\item[-]
پیچیدگی زمانی \lr{insertion sort} برابر با 
\m{O(n^2)}
است و 
\lr{constant factor}
آن بسیار بسیار پایین است چون اولا \lr{inplace} عمل می‌کند (پس نیازی به فضای اضافه ندارد) و ثانیا فقط بین عناصر آرایه پیمایش انجام می‌دهد (پس \lr{Locality of Reference} هم در آن بسیار خوب است و پردازنده می‌تواند داده‌ها را کش کند.)

\item[-]
در تحلیل‌های انجام شده روی الگوریتم‌ها، این الگوریتم روی تعداد ورودی ۶۴ و پایین‌تر از الگوریتم‌های دیگر مرتب سازی سریع‌تر عمل می‌‌کند.

\item[-]
الگوریتم 
\lr{binary insertion sort}
بجای جستجوی خطی در آرایه (با پیچیدگی \m{O(n)}) در آن جستجوی دودویی انجام داده و در زمان لوگاریتمی (\m{O(lgn)}) مکان صحیح آیتم را پیدا می‌‌کند (علت استفاده از این الگوریتم در ادامه روشن خواهد شد.)
\end{itemize}
\end{frame}
