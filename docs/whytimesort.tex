\section{چرا تیم‌سورت؟}
\begin{frame}{چرا تیم‌سورت؟}
\begin{itemize}\itemr
\item[-]
پیچیدگی زمانی الگوریتم تیم‌سورت با الگوریتم‌های 
\lr{Merge sort}،
\lr{Quick sort} و
\lr{Heap sort}
برابری می‌کند و برابر 
\m{O(nlgn)}
است.

\item[-]
اما این تحلیل کلی یک سری جزئیات راجع به پیچیدگی زمانی الگوریتم را پنهان می‌کند که آن پیچیدگی یک 
\lr{constant factor}
اثرگذار در میزان پیچیدگی الگوریتم است. (\m{c_f.nlgn})

\item[-]
برای مثال در الگوریتم \lr{Quick sort} انتخاب مقدار 
\lr{left}،
\lr{right} و
\lr{pivot}
تاثیرگذار است و در \m{n}های کوچک سرعت را پایین می‌آورد.

\item[-]
در الگوریتم 
\lr{Merge sort}
هم ما فضایی به اندازه‌ی \m{n + m} برای ادغام کردن آرایه‌ها آن هم به صورت بازگشتی و تعداد زیاد نیاز دارد. همچنین این الگوریتم یک الگوریتم بازگشتی‌ست و درخت بازگشتی و یک \lr{system stack} برای اجرا نیاز دارد.

\item[-]
بخاطر جابجایی‌هایی در الگوریتم \lr{Heap sort} انجام می‌شود، 
\lr{Locality of Reference}
در آن نقض شده و پیشبینی‌های پردازنده‌ برای کش کردن داده‌ها را تضعیف می‌کند.
\end{itemize}
\end{frame}

\begin{frame}{چرا تیم‌سورت؟}
\begin{center}
{\Large \textbf{پس اگر بتوانیم این \lr{constant factor} را کاهش دهیم}}

{\Large \textbf{می‌توانیم سرعت بیشتری از \m{O(nlgn)} بگیریم.}}
\end{center}
\end{frame}

\begin{frame}{مرتب سازی درجی دودویی}
\begin{itemize}\itemr
\item[-]
پیچیدگی زمانی \lr{insertion sort} برابر با 
\m{O(n^2)}
است و 
\lr{constant factor}
آن بسیار بسیار پایین است چون اولا \lr{inplace} عمل می‌کند (پس نیازی به فضای اضافه ندارد) و ثانیا فقط بین عناصر آرایه پیمایش انجام می‌دهد (پس \lr{Locality of Reference} هم در آن بسیار خوب است و پردازنده می‌تواند داده‌ها را کش کند.)

\item[-]
در تحلیل‌های انجام شده روی الگوریتم‌ها، این الگوریتم روی تعداد ورودی ۶۴ و پایین‌تر از الگوریتم‌های دیگر مرتب سازی سریع‌تر عمل می‌‌کند.

\item[-]
الگوریتم 
\lr{binary insertion sort}
بجای جستجوی خطی در آرایه (با پیچیدگی \m{O(n)}) در آن جستجوی دودویی انجام داده و در زمان لوگاریتمی (\m{O(lgn)}) مکان صحیح آیتم را پیدا می‌‌کند (علت استفاده از این الگوریتم در ادامه روشن خواهد شد.)
\end{itemize}
\end{frame}

\begin{frame}{مرتب‌ سازی درجی دودویی}
\begin{itemize}\itemr
\item[-]
با تعویض نوع جستجوی‌ این الگوریتم میزان پیچیدگی آن (حالت مورد انتظار و در بدترین حالت) تغییری نکرده و همان
\m{O(n^2)}
باقی می‌ماند؛ اما در 
\lr{CPython}
مقایسه‌ها (بخاطر ماهیت \lr{dynamic typed} بودن زبان) نسبت به جابجا کردن آبجکت‌ها بسیار وحشتناک کند‌تر هستند.
\item[-]
جابجا کردن آبجکت‌ها صرفا کپی کردن ۸ بایت \lr{pointer} است اما مقایسه‌ها میتوانند بسیار کند باشند (چون ممکن است چند متد در سطح پایتون را صدا بزنند) و حتی در حالات ساده ممکن است بین ۳ یا ۴ تصمیم گرفته بشود: 

\begin{enumerate}\itemr
\item 
تایپ عمل‌وند چپ چیست؟
\item 
تایپ عمل‌وند راست چیست؟
\item 
آیا باید آنها را به یک تایپ مشخص تبدیل کرد؟
\item 
چه کدی برای مقایسه این دو موجود هست؟ و...
\end{enumerate}
\end{itemize}
\end{frame}

\begin{frame}{مرتب سازی درجی دودویی}
\begin{itemize}\itemr
\item[-]
پس یک مقایسه ساده باعث تعداد بسیار زیادی \lr{C-level pointer dereference}، عملیات‌های شرطی و صدا زده شدن توابع می‌شود.

\item[-]
پس اگر ما تعداد مقایسه‌ها کمتر کنیم میتوانیم سرعت مرتب سازی را بیشتر کنیم (که با استفاده از \lr{binary insertion sort} ما تعداد مقایسه‌ها را کم می‌کنیم.)
\end{itemize}
\end{frame}

\begin{frame}{ایده}
\begin{center}
{\large اگر آرایه را به تکه‌های کوچک تقسیم کنیم‌ (برای مثال ۳۲ تا ۶۴ تایی) و سپس آنها را جدا جدا با مرتب‌ سازی درجی مرتب کنیم و سپس همه را ادغام کنیم، می‌توانیم سرعت مرتب سازی را افزایش دهیم.}
\end{center}

\begin{enumerate}\itemr
\item
چون از مرتب سازی درجی که برای تعداد کم سریع است استفاده کردیم (\m{c_i(32 \ to\ 64)^2})،
\item
ادغام دو آرایه مرتب شده در زمان 
\m{O(n)}
انجام می‌شود و

\item 
با این کار ما توانستیم ۵ سطح از درختی در \lr{Merge sort} تولید می‌شود را کم کنیم (\m{c_t.n[lgn - 5]})
\end{enumerate}

\begin{center}
{\large در نهایت چون مقدار پیچیدگی مرتب سازی درجی کوچک است، پیچیدگی  تیم‌سورت چنین می‌شود: \m{T(n) = c_t.n[lgn - 5]}}
\end{center}
\end{frame}
