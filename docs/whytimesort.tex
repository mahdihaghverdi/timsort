\section{چرا تیم‌سورت؟}
\begin{frame}{چرا تیم‌سورت؟}
\begin{itemize}\itemr
\item[-]
پیچیدگی زمانی الگوریتم تیم‌سورت با الگوریتم‌های 
\lr{Merge sort}،
\lr{Quick sort} و
\lr{Heap sort}
برابری می‌کند و برابر 
\m{O(nlgn)}
است.

\item[-]
اما این تحلیل کلی یک سری جزئیات راجع به پیچیدگی زمانی الگوریتم را پنهان می‌کند که آن پیچیدگی یک 
\lr{constant factor}
اثرگذار در میزان پیچیدگی الگوریتم است. (\m{c_f.nlgn})

\item[-]
برای مثال در الگوریتم \lr{Quick sort} انتخاب مقدار 
\lr{left}،
\lr{right} و
\lr{pivot}
تاثیرگذار است و در \m{n}های کوچک سرعت را پایین می‌آورد.

\item[-]
در الگوریتم 
\lr{Merge sort}
هم ما فضایی به اندازه‌ی \m{n + m} برای ادغام کردن آرایه‌ها آن هم به صورت بازگشتی و تعداد زیاد نیاز دارد. همچنین این الگوریتم یک الگوریتم بازگشتی‌ست و درخت بازگشتی و یک \lr{system stack} برای اجرا نیاز دارد.

\item[-]
بخاطر جابجایی‌هایی در الگوریتم \lr{Heap sort} انجام می‌شود، 
\lr{Locality of Reference}
در آن نقض شده و پیشبینی‌های پردازنده‌ برای کش کردن داده‌ها را تضعیف می‌کند.
\end{itemize}
\end{frame}

\begin{frame}{چرا تیم‌سورت؟}
\begin{center}
{\Large \textbf{پس اگر بتوانیم این \lr{constant factor} را کاهش دهیم}}

{\Large \textbf{می‌توانیم سرعت بیشتری از \m{O(nlgn)} بگیریم.}}
\end{center}
\end{frame}

\begin{frame}{مرتب سازی درجی دودویی}
\begin{itemize}\itemr
\item[-]
پیچیدگی زمانی \lr{insertion sort} برابر با 
\m{O(n^2)}
است و 
\lr{constant factor}
آن بسیار بسیار پایین است چون اولا \lr{inplace} عمل می‌کند (پس نیازی به فضای اضافه ندارد) و ثانیا فقط بین عناصر آرایه پیمایش انجام می‌دهد (پس \lr{Locality of Reference} هم در آن بسیار خوب است و پردازنده می‌تواند داده‌ها را کش کند.)

\item[-]
در تحلیل‌های انجام شده روی الگوریتم‌ها، این الگوریتم روی تعداد ورودی ۶۴ و پایین‌تر از الگوریتم‌های دیگر مرتب سازی سریع‌تر عمل می‌‌کند.

\item[-]
الگوریتم 
\lr{binary insertion sort}
بجای جستجوی خطی در آرایه (با پیچیدگی \m{O(n)}) در آن جستجوی دودویی انجام داده و در زمان لوگاریتمی (\m{O(lgn)}) مکان صحیح آیتم را پیدا می‌‌کند (علت استفاده از این الگوریتم در ادامه روشن خواهد شد.)
\end{itemize}
\end{frame}

\begin{frame}{مرتب‌ سازی درجی دودویی}
\begin{itemize}\itemr
\item[-]
با تعویض نوع جستجوی‌ این الگوریتم میزان پیچیدگی آن (حالت مورد انتظار و در بدترین حالت) تغییری نکرده و همان
\m{O(n^2)}
باقی می‌ماند؛ اما در 
\lr{CPython}
مقایسه‌ها (بخاطر ماهیت \lr{dynamic typed} بودن زبان) نسبت به جابجا کردن آبجکت‌ها بسیار وحشتناک کند‌تر هستند.
\item[-]
جابجا کردن آبجکت‌ها صرفا کپی کردن ۸ بایت \lr{pointer} است اما مقایسه‌ها میتوانند بسیار کند باشند (چون ممکن است چند متد در سطح پایتون را صدا بزنند) و حتی در حالات ساده ممکن است بین ۳ یا ۴ تصمیم گرفته بشود: 

\begin{enumerate}\itemr
\item 
تایپ عمل‌وند چپ چیست؟
\item 
تایپ عمل‌وند راست چیست؟
\item 
آیا باید آنها را به یک تایپ مشخص تبدیل کرد؟
\item 
چه کدی برای مقایسه این دو موجود هست؟ و...
\end{enumerate}
\end{itemize}
\end{frame}

\begin{frame}{مرتب سازی درجی دودویی}
\begin{itemize}\itemr
\item[-]
پس یک مقایسه ساده باعث تعداد بسیار زیادی \lr{C-level pointer dereference}، عملیات‌های شرطی و صدا زده شدن توابع می‌شود.

\item[-]
پس اگر ما تعداد مقایسه‌ها کمتر کنیم میتوانیم سرعت مرتب سازی را بیشتر کنیم (که با استفاده از \lr{binary insertion sort} ما تعداد مقایسه‌ها را کم می‌کنیم.)
\end{itemize}
\end{frame}

\begin{frame}{ایده}
\begin{center}
{\large اگر آرایه را به تکه‌های کوچک تقسیم کنیم‌ (برای مثال ۳۲ تا ۶۴ تایی) و سپس آنها را جدا جدا با مرتب‌ سازی درجی مرتب کنیم و سپس همه را ادغام کنیم، می‌توانیم سرعت مرتب سازی را افزایش دهیم.}
\end{center}

\begin{enumerate}\itemr
\item
چون از مرتب سازی درجی که برای تعداد کم سریع است استفاده کردیم (\m{c_i(32 \ to\ 64)^2})،
\item
ادغام دو آرایه مرتب شده در زمان 
\m{O(n)}
انجام می‌شود و

\item 
با این کار ما توانستیم ۵ سطح از درختی در \lr{Merge sort} تولید می‌شود را کم کنیم (\m{c_t.n[lgn - 5]})
\end{enumerate}

\begin{center}
{\large در نهایت چون مقدار پیچیدگی مرتب سازی درجی کوچک است، پیچیدگی  تیم‌سورت چنین می‌شود: \m{T(n) = c_t.n[lgn - 5]}}
\end{center}
\end{frame}

\begin{frame}{حقیقت}
\begin{center}
{\large در دنیای واقعی و داده‌های واقعی معمولا آرایه‌ها اصطلاحا 
\lr{partially sorted}
هستند.}
\end{center}
\begin{itemize}\itemr
\item[-]
این به این معناست که تکه‌هایی از آرایه از قبل مرتب هستند؛ برای مثال در این آرایه:
\m{[5, 4, 1, 2, 3]}
قسمت 
\m{[1, 2, 3]}
از قبل مرتب است.
\item[-]
یا حداقل به صورت صعودی یا نزولی پشت سر هم حضور دارند؛ برای مثال در این آرایه:
\m{[6, 4, 1, 2, 3, 5, 7]}
قسمت
\m{[1, 2, 3, 5, 7]}
خودش به صورت صعودی مرتب است.
\end{itemize}

\begin{center}
{\large الگوریتم تیم‌سورت این تکه‌های صعودی و یا اکیدا نزولی را در آرایه پیدا می‌کند و آنها را \lr{Run} می‌نامد و از مرتب بودن اولیه آرایه برای افزایش سرعت استفاده می‌کند.}
\end{center}
\end{frame}

\begin{frame}{نتیجه}
\begin{itemize}\itemr
\item[-]
اگر از حقیقت قبلی استفاده کنیم و آرایه را به قسمت‌هایی صعودی و یا اکیدا نزولی تقسیم کنیم می‌توانیم درخت \lr{Merge sort} حتی بیشتر از قبل هم کوتاه کنیم.

\item[-]
و پیچیدگی را به 
\m{c_t.n[lgn - x]}
تبدیل کنیم.
\end{itemize}
\end{frame}

\begin{frame}{\lr{Run}ها}
\begin{itemize}\itemr
\item[-]
تابع 
\lr{\texttt{count\_run()}}\fn{1}{\url{https://github.com/python/cpython/blob/3.10/Objects/listobject.c\#L1316}}
تعداد عنصر موجود در \lr{Run} را بر می‌گرداند.

\item[-]
\lr{Run}ها
میتوانند:
\begin{enumerate}\itemr
\item
صعودی باشند:
\m{a_0 \leq a_1 \leq a_2 \leq \dots}

\item 
اکیدا نزولی باشند:
\m{a_0 > a_1 > a_2 > \dots}
\end{enumerate}
\item[-]
دلیل اینکه یک \lr{Run} باید نزولی اکید باشد تا یک \lr{Run} شناخته شود اینست که الگوریتم تیم‌سورت \lr{Run}‌های نزولی را به صورت در جا، برعکس می‌کند\fn{2}{\url{https://github.com/python/cpython/blob/3.10/Objects/listobject.c\#L1064}} و اگر در یک \lr{Run} نزولی (و نه اکیدا نزولی) دو عنصر یکسان باشند، ماهیت \lr{stable} بودن الگوریتم نقض می‌شود. برای مثال این‌ آرایه: 
\m{\left[4, \textcolor{red}{3}, \textcolor{blue}{3}, 1\right]}
اگر برعکس شود:
\m{\left[1, \textcolor{blue}{3}, \textcolor{red}{3}, 4\right]}
؛ که ترتیب عناصر ۳ عوض شده است. اما اگر اکیدا نزولی باشد دیگر این مشکل وجود نخواهد داشت.
\end{itemize}
\end{frame}

\begin{frame}{\lr{Run}ها}
\begin{itemize}\itemr
\item[-]
نکته‌ی دیگر اینست که \lr{Run}ها حداقل دو آیتم دارند مگر وقتی که آخرین عضو آرایه را برای \lr{Run} جدید برگزینیم.
\item[-]
اگر عناصر آرایه رندوم باشند، بعید است که ما \lr{Run}های طبیعی (یعنی قسمتی از آرایه که از قبل مرتب شده باشد) بلندی را شاهد باشیم. اگر یک \lr{Run} طبیعی تعداد عناصرش کمتر از \lr{minrun} باشد (توضیح داده خواهد شد،) الگوریتم با استفاده از \lr{binray insertion sort} تعداد آنرا به حداقل اندازه‌ی \lr{Run} می‌رساند.

\item[-]
دلیلی که می‌توانیم از \lr{binary insertion sort} استفاده کنیم اینست که هر \lr{Run} خودش مرتب است، پس می‌توان در آن جستجوی دودویی انجام داد.
\end{itemize}
\end{frame}

\begin{frame}{\lr{Run}ها}
\begin{itemize}\itemr
\item[-]
الگوریتم برای پیدا کردن \lr{Run}ها چنین عمل می‌کند: فرض کنید چنین آرایه‌ای داریم:
\m{\left[8, 12, 9, 17, 15, -1, 22, 11, 10, 7\right]}
و حداقل اندازه‌ی \lr{Run}ها هم ۳ تعیین شده است،

\item[-]
از چپ به راست حرکت می‌کنیم و 
\m{\left[8\right]}
را جدا می‌کنیم و سراغ آیتم بعدی می‌رویم و متوجه می‌شویم که یک \lr{Run} صعودی داریم:
\m{\left[8, 12\right]}
ادامه ‌می‌دهیم و به عدد ۹ می‌رسیم، چون این \lr{Run} باید صعودی باشد و ۹ از ۱۲ کمتر است با استفاده از \lr{binary insertion sort} جایگاه ۹ را پیدا می‌کنیم:
\m{\left[8, 9, 12\right]}

\item[-]
عدد بعدی هم بزرگ‌تر از ۱۲ است و آن را هم به این \lr{Run} اضافه می‌کنیم:
\m{\left[8, 9, 12, 17\right]}.
عدد بعدی، از ۱۷ کمتر است و چون ما حداقل اندازه‌ی یک \lr{Run} را داریم آنرا دیگر به این \lr{Run} اضافه نمیکنیم و به سراغ \lr{Run} بعدی می‌رویم.

\item[-]
\lr{Run}
 بعدی چنین روندی دارد:
\m{\left[15\right]}
سپس 
\m{\left[15, -1\right]}
و سپس با \lr{binary insertion sort}:
\m{\left[22, 15, -1\right]}
و چون 11 از 1- بیشتر است و ما حداقل اندازه‌ی یک \lr{Run} را داریم به سراغ \lr{Run} بعدی می‌رویم؛ که \lr{Run} بعدی هم چنین است:
\m{\left[11, 10, 7\right]}
\end{itemize}
\end{frame}

\begin{frame}{\lr{Run}ها}
\begin{itemize}\itemr
\item[-]
اگر داده‌های رندوم باشند، اکثر \lr{Run}ها یک اندازه خواهند داشت که دو خوبی دارد:
\begin{enumerate}\itemr
\item 
ادغام کردن \lr{Run}هایی که اندازه‌ی برابر دارند بسیار بهینه است و
\item 
ما حداقل توانسته‌ایم اندازه‌ی درخت بازگشتی ادغام را به اندازه‌ی 
\m{log(minrun)}
کم کنیم.
\end{enumerate}

\item[-]
برای داده‌های واقعی هم، ما چون \lr{Run}های نسبتا بلندی خواهیم داشت توانسته‌ایم کوتاه‌ترین درخت بازگشتی ادغام را داشته باشیم و در نتیجه تعداد ادغام‌ها را کم کنیم.
\end{itemize}
\end{frame}