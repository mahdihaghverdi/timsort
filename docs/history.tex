\section{تاریخچه}
\begin{frame}{تاریخچه}
\begin{itemize}\itemr
\item[-]
الگوریتم تیم‌سورت، در سال ۲۰۰۲ توسعه یافت.

\item[-]
تیم‌ پیترز این الگوریتم را اینگونه توصیف می‌کند:
\begin{flushleft}
\begin{latin}
``A non-recursive adaptive stable natural mergesort / binary insertion sort hybrid algorithm''
\end{latin}
\end{flushleft}

\item[-]
این الگوریتم از 
\lr{Python 2.3}
تا حدود بیست سال، الگوریتم استاندارد مرتب‌سازی در پایتون بود و از ورژن 
\lr{3.11.1}
به دلیل تغییراتی که در سیاست‌های ادغام آن بوجود آمد، الگورتیمی به اسم 
\lr{Powersort}
بر پایه‌ی تیم‌سورت، جایگزین آن شد.

\item[-]
الگوریتم تیم‌سورت در 
\lr{Java SE 7}،
\lr{Android}،
\lr{GNU Octave}،
\lr{V8}،
\lr{Swift} و 
\lr{Rust}
پیاده‌سازی شده است.
\end{itemize}
\end{frame}

\begin{frame}{چراها}
\begin{itemize}\itemr
\item[-]
چرا \lr{non-recursive}؟

چون طبق گفته‌ی تیم پیترز: «به طور خلاصه، روتین اصلی یک بار از سمت چپ تا راست، آرایه را طی، \lr{run}‌ها\RLfn{2}{\rl{در ادامه مفهوم \lr{run} توضیح داده می‌شود.}} را شناسایی و هوشمندانه‌ آنها را با هم ادغام می‌کند.»

\item[-]
چرا \lr{adaptive}؟

چون این الگوریتم با توجه به طول و ترتیب‌های از قبل موجود در آرایه، و همچنین بر اساس اندازه‌‌ی 
\lr{run}های
پیدا شده، تصمیماتی می‌گیرد تا از الگوریتم بهتری برای آن موقعیت استفاده کند.

\item[-]
چرا \lr{stable}؟

چون این الگوریتم، ترتیب عناصر یکسان در آرایه‌ی اولیه را حفظ می‌کند. برای مثال اگر لیستی از این اسامی داشته باشیم: 
\m{\left[peach, straw, apple, spork\right]}
و آنرا بخواهیم بر اساس حرف اول کلمات مرتب کنیم، چنین چیزی می‌گیریم:
\m{\left[apple, peach, straw, spork\right]}
اگر دقت کنید در لیست اولیه، \m{straw} قبل از \m{spork} آمده بود و در لیست مرتب شده هم همین ترتیب حفظ شد. به این نگهداری ترتیب پایداری الگوریتم مرتب‌سازی می‌گویند.
\end{itemize}
\end{frame}

\begin{frame}{چراها}
\begin{itemize}\itemr
\item[-]
چرا \lr{hybrid}؟

چون این الگوریتم از ترکیب دو الگوریتم 
\lr{merge sort}
و
\lr{binary insertion sort}
برای مرتبسازی استفاده می‌کند.
\end{itemize}
\end{frame}