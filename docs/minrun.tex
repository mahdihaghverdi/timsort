\begin{frame}{محاسبه‌ی \lr{\texttt{minrun}}}
\begin{itemize}\itemr
\item[-]
اگر طول آرایه‌ کمتر از 64 باشد، از 
\lr{binary insertion sort}
برای مرتب کردن آن استفاده می‌شود.

\item[-]
اگر طول آرایه توانی از ۲ بود، طبق تست‌های انجام شده تمامی اعداد ۸ و ۱۶و ۳۲ و ۶۴ و ۱۲۸ سرعت یکسانی را به الگوریتم می‌دادند اما مثلا در اندازه‌ی ۲۵۶ تا جابجا کردن عناصر در مرتب ‌سازی هزینه بردار و در انداز‌ه‌ی ۸ تعداد صدا زده شدن توابع هزینه‌ بردار بود. بعد از کمی مطالعه عدد ۳۲ برای \lr{minrun} انتخاب شد.

\item[-]
اما بعد از زمان زیادی یک اشکال در انتخاب این عدد پیدا شد، این مثال را ببینید:
\begin{flushleft}
\lr{\texttt{divmod(2112, 32) -> (66, 0)}}
\end{flushleft}
که اگر با این تعداد \lr{Run} ما ادغام را انجام بدهیم، در پایان باید یک آرایه‌ی ۲۰۴۸ عضوی و یک آرایه‌ی ۶۴ عضوی را با هم ادغام کنیم که اصلا خوب نیست.

\item[-]
اما اگر عدد ۳۳ را برای \lr{\texttt{minrun}} انتخاب کنیم ما ۶۴ تا \lr{Run} با اندازه‌ی ۳۳ داریم که برای ادغام خیلی بهتر است.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{محاسبه‌ی \lr{\texttt{minrun}} (ادامه)}
\begin{itemize}\itemr
\item[-]
سیاستی که برای محاسبه‌ی \lr{\texttt{minrun}} در پیش گرفته شده است اینست که این مقدار از \lr{\texttt{range(32, 64)}} به صورتی انتخاب می‌شود که \lr{\texttt{N/minrun}} یا دقیقا توانی از دو باشد، یا اگر این ممکن نبود، اکیدا کمتر از توان ۲ باشد.

\item[-]
این انتخاب توسط تابع
\lr{\texttt{merge\_compute\_minrun()}}\fn{1}{\url{https://github.com/python/cpython/blob/3.10/Objects/listobject.c\#L2012}}
انجام می‌شود.
\end{itemize}
\end{frame}
