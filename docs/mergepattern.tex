\section{توضیح الگوریتم - ادغام‌ها}
\begin{frame}{بهتر کردن استفاده از فضا در ادغام}
\begin{itemize}\itemr
\item[-]
الگوریتم ادغام در \lr{Merge sort} الگوریتمی \lr{inplace} نیست و برای ادغام کردن دو آرایه با طول‌های
\m{n}
و
\m{m}
یک آرایه‌ی جدید به طول
\m{n + m}
نیاز دارد و در کل برای ادغام ما چنین فضایی را اشغال کرده‌ایم:
\begin{flushleft}
\m{\underbrace{\m{n}}_{len(X)} + \underbrace{\m{m}}_{len(Y)} + \underbrace{\m{n + m}}_{\text{\lr{new array}}}}
\end{flushleft}

\item[-]
اما تیم‌سورت برای \lr{inplace} مرتب کردن و کمتر کردن 
\lr{space overhead}
الگوریتم مرتب سازی ادغامی از روش بهتری برای ادغام کردن دو \lr{Run} استفاده می‌کند.
\end{itemize}
\end{frame}

\begin{frame}{بهتر کردن استفاده از فضا در ادغام (ادامه)}
\begin{itemize}\itemr
\item[-]
اگر آرایه‌ای به این صورت داشته باشیم:
\begin{latin}
\begin{flushleft}
\m{A = [\,\underbrace{\m{3, 5, 17, 22, 107, 109}}_{\m{X}}, \, \underbrace{\m{12, 19, 21, 22}}_{\m{Y}} \,]}
\end{flushleft}
\end{latin}
دو \lr{Run} عه 
\m{X}
و
\m{Y}
در آن می‌توان شناسایی کرد.

\item[-]
در این روش جدید ادغام ما یک آرایه‌ی موقت به اندازه‌ی \lr{Run} کوچک‌تر درست می‌کنیم و عناصر \lr{Run} کوچک‌تر را در آن کپی می‌کنیم. کپی کردن‌های این چنین هم به بهینه‌ترین در سطح پایین اجرا می‌شوند. پس حالا ما چنین چیزی داریم:

\begin{latin}
\begin{flushleft}
\m{A = [3, 5, 17, 22, 107, 109, 12, 19, 21, 22]}\\
\m{T = [12, 19, 21, 22]}
\end{flushleft}
\end{latin}
\end{itemize}
\end{frame}

